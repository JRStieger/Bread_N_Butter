function WaveletFilterJake(sbj_name, project_name, bn, dirs,el,freq_band,span,fs_targ, norm, datatype)

%% INPUTS
%   sbj_name:               subject name
%   project_name:           name of task
%   bn:                     names of blocks to be analyed (cell of strings)
%   dirs:                   directories pointing to files of interest (generated by InitializeDirs)
%   el (optional):          can select subset of electrodes to epoch (default: all)
%   freq_band:              vector containing frequencies at which wavelet is computed (in Hz),
%                           or string (e.g. 'HFB') corresponding to
%                           particular set of freqs (returned by genFreqs.m)
%   span (optional):        span of wavelet (i.e. width of gaussian that forms
%                           wavelet, in units of cycles- specific to each
%                           frequency)
%   fs_targ (optional):     target sampling rate of wavelet output
%   norm (optional):        normalize amplitude of timecourse within each frequency
%                           band (to eliminate 1/f power drop with frequency)
%   datatype :              'Band' or 'Spec'
%
%
if strcmp(datatype,'Band')
    avgfreq = true;
else
    avgfreq = false;
end

block_name = bn;

fsep = filesep;
data_root = [];
data_root = strjoin({dirs.data_root,([datatype,'Data']),freq_band,sbj_name,bn},fsep);
fn_out = strjoin({dirs.data_root,([datatype,'Data']),freq_band,sbj_name,bn,...
    [freq_band,'iEEG',bn,'_',num2str(el,'%.2d'),'.mat']},fsep);
  
%skip if data has already been calculated
if exist(fn_out)
    fprintf('Frequency decomposition %s already exists...moving on\n',[freq_band,'iEEG',bn,'_',num2str(el,'%.2d'),'.mat'])
    return
end

if ~ischar(freq_band)
    freqs = freq_band;
    % if freq_band input contains numbers, create label for band
    freq_band = [num2str(freqs(1)),'_to_',num2str(freqs(end))];
    freq_band = strrep(freq_band,'.','_');
else
    freqs = genFreqs(freq_band);
end

if isempty(span)
    span = 1;
end
if isempty(norm)
    norm = true;
end
%%
% Load globalVar
gn = strjoin({'global',project_name,sbj_name,[bn,'.mat']},'_');
gfn = strjoin({dirs.data_root,'originalData',sbj_name,gn},fsep);
load(gfn,'globalVar');

if strcmp(datatype,'Band')
    data_root=fullfile(dirs.data_root,'BandData');%globalVar.BandData;  
else
    data_root=fullfile(dirs.data_root,'SpecData');%globalVar.SpecData; 
end


dir_out = [data_root,filesep,freq_band,filesep,sbj_name,filesep,bn];
if ~exist(dir_out, 'dir')
    mkdir(dir_out)
end

%target sampling frequency defaults
if isempty(fs_targ)
    if avgfreq
        fs_targ = 500;
    else
        fs_targ = 200;
    end
end

%% Per electrode
disp(['Wavelet filtering: Block ', bn,', Elec ',num2str(el)])

chan = el;
chan_lbl = globalVar.channame{el};
data = loadAndWaveletDecompose(sbj_name,chan,chan_lbl,...
    block_name,dirs);

if ~exist(data_root)
   mkdir(data_root) 
end

save(fn_out,'data')



end


function cmw = morwav(freq,ncycles,samp_rate)
%""" Create a Complex morelet wavelet """
if freq < 4
    t_min = 2*ncycles/freq;
else
    t_min = 2;
end
time = -t_min:1/samp_rate:t_min;
s = ncycles/(2*pi*freq);
A = 1/(sqrt(s*sqrt(pi)));
cmw = A.*exp((-1.*(time.^2))/(2*s^2)).*exp(1j*2*pi*freq.*time);
end


function wave_data = waveletFilter(signal,time,samp_rate,freqs,cfg)
%Function will compute the wavelet decomposition of the signal
%{
    Parameters cfg needs:
    1. scales - number of cycles per frequency
    2. fnorm - 'db' decibels, 'z' z-score
%}

%input parameters
scales = cfg.scales;
n_data = length(signal);
nfft = 0;
%initialize structures
power = zeros(length(freqs),length(signal));
phase = zeros(length(freqs),length(signal));
%bandpass = zeros(length(freqs),length(signal));
%}
%loop through frequencies
for i = 1:length(freqs)
    freq = freqs(i);
    ncycles = scales(i);
    %get the wavelet
    cm_wav = morwav(freq,ncycles,samp_rate);
    %size parameters
    n_wavelet = length(cm_wav);
    n_convolution = n_wavelet+n_data-1;
    half_of_wavelet_size = floor((n_wavelet-1)/2);
    new_fft_len = 2^nextpow2(n_convolution);
    if new_fft_len ~= nfft
        %re-compute fft
        nfft = new_fft_len;
        signal_FFT = fft(signal,nfft);
    end
    
    %fft wavelet
    wav_fft = fft(cm_wav,nfft);
    %multiply
    conv_fft = signal_FFT.*wav_fft;
    %convert back into time domain
    wav_conv = ifft(conv_fft,nfft);
    wav_conv = wav_conv((half_of_wavelet_size+1):(length(signal)+half_of_wavelet_size));
    %get the power
    freq_pow = (wav_conv.*conj(wav_conv));
    power(i,:) = real(freq_pow);
    %get phase
    phase(i,:) = angle(wav_conv);
    %get the bandpass
    %bandpass(i,:) = real(wav_conv);
    %}
end%for freqs

%downsample
new_power = power(:,1:cfg.dsrate:end);
new_phase = phase(:,1:cfg.dsrate:end);
%new_bandpass = bandpass(:,1:cfg.dsrate:end);
new_time = time(1:cfg.dsrate:end);
new_fsamp = round(samp_rate/cfg.dsrate);

%normalize power across run to mean for 1/f adjustment
if strcmp(cfg.fnorm,'db')
    new_power = 10.*log10((new_power+0.0000001)./median(new_power,2));
elseif strcmp(cfg.fnorm,'z')
    new_power = zscore(new_power,[],2);
end

%return structure
wave_data.wave = new_power;
wave_data.phase = new_phase;
wave_data.freqs = freqs;
wave_data.time = new_time;
wave_data.fsample = new_fsamp;

end%function wavelet filter

function data = loadAndWaveletDecompose(sbj_name,chan,chan_lbl,...
    block_name,dirs)

%wavelet parameters
cycle_cell = {'log8'};
cfg = [];
cfg.freqs = genFreqs('SpecDense');
cfg.dsrate = 5;
cfg.windsor = 0;
cfg.cycle_name = 'lin8';
cfg.scales = linspace(1,8,numel(cfg.freqs));
cfg.fnorm = 'db';

%load the trialinfo
fn = strjoin({dirs.psych_root,sbj_name,block_name,...
    ['trialinfo_',block_name,'.mat']},filesep);
tmp = load(fn);
trialinfo = tmp.trialinfo;
%load the data
if chan < 10
    load_fn = strjoin({dirs.data_root,'CARData','CAR',sbj_name,...
        block_name,sprintf('CARiEEG%s_0%i.mat',block_name,chan)},...
        filesep);
else
    load_fn = strjoin({dirs.data_root,'CARData','CAR',sbj_name,...
        block_name,sprintf('CARiEEG%s_%i.mat',block_name,chan)},...
        filesep);
end%if channame needs zero
tmp = load(load_fn);
data = tmp.data;
data.fsample = round(data.fsample);
if data.fsample ~= 1000
    error('wrong sampling freq')
end

%get frequency decomposition based on configuration
signal = data.wave;
time = linspace(1/data.fsample,length(signal)/data.fsample,length(signal));
data = waveletFilter(signal,time,data.fsample,cfg.freqs,cfg);
data.label = chan_lbl;
%winsor the data
if cfg.windsor
    data = windsor_wave(data);
end

end%load and wavelet decompose

function data = windsor_wave(data)
for f = 1:length(data.freqs)
    tmp_data = data.wave(f,:);
    high_val = prctile(data.wave(f,:),99);
    low_val = prctile(data.wave(f,:),1);
    tmp_data(tmp_data > high_val) = high_val;
    tmp_data(tmp_data < low_val) = low_val;
    data.wave(f,:) = tmp_data;
end
end%windsor wave